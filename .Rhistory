if(!(stream_order %in% colnames(constrained_strm))) {
stop(paste0("Could not find a column named ", stream_order, ". Check stream_order argument"))
}
vals <- constrained_strm[, stream_order]
sf::st_geometry(vals) <- NULL
vals <- vals[, 1]
vals <- as.numeric(vals)
constrained_strm$tmp_stream_order <- vals
# Fix stream order column name
if(!(stream_order %in% colnames(strm))) {
stop(paste0("Could not find a column named ", stream_order, ". Check stream_order argument"))
}
vals <- strm[, stream_order]
sf::st_geometry(vals) <- NULL
vals <- vals[, 1]
vals <- as.numeric(vals)
strm$tmp_stream_order <- vals
# Recreate stream road crossings
sc1 <- suppressWarnings({ sf::st_intersection(roads, strm) })
sc2 <- suppressWarnings({ sf::st_intersection(roads, constrained_strm) })
# Generate Summary Table For Stream Lengths
if(summary_type == "stream_lengths") {
strm$strata <- NA
strm$strata <- ifelse(strm$STREAM_ORDER < 3, "stratum_1", strm$strata)
strm$strata <- ifelse(strm$STREAM_ORDER >= 3, "stratum_2", strm$strata)
constrained_strm$strata <- NA
constrained_strm$strata <- ifelse(constrained_strm$STREAM_ORDER < 3, "stratum_1", constrained_strm$strata)
constrained_strm$strata <- ifelse(constrained_strm$STREAM_ORDER >= 3, "stratum_2", constrained_strm$strata)
strm$length_m <- as.numeric(sf::st_length(strm))
constrained_strm$length_m <- as.numeric(sf::st_length(constrained_strm))
c1 <- sum(constrained_strm$length_m[which(constrained_strm$strata == "stratum_1")])
c2 <- sum(constrained_strm$length_m[which(constrained_strm$strata == "stratum_2")])
c3 <- sum(constrained_strm$length_m)
u1 <- sum(strm$length_m[which(strm$strata == "stratum_1")])
u2 <- sum(strm$length_m[which(strm$strata == "stratum_2")])
u3 <- sum(strm$length_m)
df <- data.frame(
strata = c("stratum_1", "stratum_2", "total"),
unconstrained = c(u1, u2, u3),
constrained = c(c1, c2, c3)
)
df$constrained <- round(df$constrained)
df$unconstrained <- round(df$unconstrained)
return(df)
}
df
sc1$strata <- NA
sc1$strata <- ifelse(sc1$STREAM_ORDER < 3, "stratum_1", sc1$strata)
sc1$strata <- ifelse(sc1$STREAM_ORDER >= 3, "stratum_2", sc1$strata)
sc2$strata <- NA
sc2$strata <- ifelse(sc2$STREAM_ORDER < 3, "stratum_1", sc2$strata)
sc2$strata <- ifelse(sc2$STREAM_ORDER >= 3, "stratum_2", sc2$strata)
c1 <- nrow(sc1[which(sc1$strata == "stratum_1"), ])
c2 <- nrow(sc1[which(sc1$strata == "stratum_2"), ])
c3 <- nrow(sc1)
u1 <- nrow(sc2[which(sc2$strata == "stratum_1"), ])
u2 <- nrow(sc2[which(sc2$strata == "stratum_2"), ])
u3 <- nrow(sc2)
df <- data.frame(
strata = c("stratum_1", "stratum_2", "total"),
unconstrained = c(c1, c2, c3),
constrained = c(u1, u2, u3),
)
df <- data.frame(
strata = c("stratum_1", "stratum_2", "total"),
unconstrained = c(c1, c2, c3),
constrained = c(u1, u2, u3)
)
df
df$constrained <- round(df$constrained)
df$unconstrained <- round(df$unconstrained)
df
#' @title Sample Frame Summary Table
#'
#' @description
#' Produce a summary table of the sampling frame.
#'
#' @details
#' It can be convenient to produce a summary table of the entire sampling frame by strata. This function summarizes the total length of streams by strata and the total count of stream crossings by strata.
#'
#' @param strm A streamline data set of class `sf` from the BCFWA. Run `utm_projection()` first to ensure projection is in meters.
#' @param constrained_strm A the constrained streamline data set of class `sf`. Generally this layer is produced as a derivative of the `strm` layer after constraining NCD, excluding lentic areas and removing alpine areas.
#' @param roads A road network data set of class `sf`. Run `utm_projection()` first to ensure projection is in meters.
#' @param stream_order String. Column name for stream order. Defaults to `STREAM_ORDER`. Rename as needed. Stream order is used to define the sampling strata.
#' @param summary_type String. Which summary table should be produced? Options include `stream_lengths` for a summary of stream lengths by strata or `stream_crossings` for summary of stream crossings by strata. Rename as needed. Stream order is used to define the sampling strata.
#' @importFrom magrittr %>%
#'
#' @return
#' A summary table according to the `summary_type`.
#'
#'
#' @export
sample_frame_summary <- function(strm = NA,
constrained_strm = NA,
roads = NA,
stream_order = "STREAM_ORDER",
summary_type = "stream_lengths") {
# Fix stream order column name
if (!(stream_order %in% colnames(constrained_strm))) {
stop(
paste0(
"Could not find a column named ",
stream_order,
". Check stream_order argument"
)
)
}
vals <- constrained_strm[, stream_order]
sf::st_geometry(vals) <- NULL
vals <- vals[, 1]
vals <- as.numeric(vals)
constrained_strm$tmp_stream_order <- vals
# Fix stream order column name
if (!(stream_order %in% colnames(strm))) {
stop(
paste0(
"Could not find a column named ",
stream_order,
". Check stream_order argument"
)
)
}
vals <- strm[, stream_order]
sf::st_geometry(vals) <- NULL
vals <- vals[, 1]
vals <- as.numeric(vals)
strm$tmp_stream_order <- vals
# Recreate stream road crossings
sc1 <- suppressWarnings({
sf::st_intersection(roads, strm)
})
sc2 <-
suppressWarnings({
sf::st_intersection(roads, constrained_strm)
})
# Generate Summary Table For Stream Lengths
if (summary_type == "stream_lengths") {
strm$strata <- NA
strm$strata <-
ifelse(strm$STREAM_ORDER < 3, "stratum_1", strm$strata)
strm$strata <-
ifelse(strm$STREAM_ORDER >= 3, "stratum_2", strm$strata)
constrained_strm$strata <- NA
constrained_strm$strata <-
ifelse(constrained_strm$STREAM_ORDER < 3,
"stratum_1",
constrained_strm$strata)
constrained_strm$strata <-
ifelse(constrained_strm$STREAM_ORDER >= 3,
"stratum_2",
constrained_strm$strata)
strm$length_m <- as.numeric(sf::st_length(strm))
constrained_strm$length_m <-
as.numeric(sf::st_length(constrained_strm))
c1 <-
sum(constrained_strm$length_m[which(constrained_strm$strata == "stratum_1")])
c2 <-
sum(constrained_strm$length_m[which(constrained_strm$strata == "stratum_2")])
c3 <- sum(constrained_strm$length_m)
u1 <- sum(strm$length_m[which(strm$strata == "stratum_1")])
u2 <- sum(strm$length_m[which(strm$strata == "stratum_2")])
u3 <- sum(strm$length_m)
df <- data.frame(
strata = c("stratum_1", "stratum_2", "total"),
unconstrained = c(u1, u2, u3),
constrained = c(c1, c2, c3)
)
df$constrained <- round(df$constrained)
df$unconstrained <- round(df$unconstrained)
return(df)
}
# Generate Summary Table For Stream Lengths
if (summary_type == "stream_crossings") {
sc1$strata <- NA
sc1$strata <-
ifelse(sc1$STREAM_ORDER < 3, "stratum_1", sc1$strata)
sc1$strata <-
ifelse(sc1$STREAM_ORDER >= 3, "stratum_2", sc1$strata)
sc2$strata <- NA
sc2$strata <-
ifelse(sc2$STREAM_ORDER < 3, "stratum_1", sc2$strata)
sc2$strata <-
ifelse(sc2$STREAM_ORDER >= 3, "stratum_2", sc2$strata)
c1 <- nrow(sc1[which(sc1$strata == "stratum_1"),])
c2 <- nrow(sc1[which(sc1$strata == "stratum_2"),])
c3 <- nrow(sc1)
u1 <- nrow(sc2[which(sc2$strata == "stratum_1"),])
u2 <- nrow(sc2[which(sc2$strata == "stratum_2"),])
u3 <- nrow(sc2)
df <- data.frame(
strata = c("stratum_1", "stratum_2", "total"),
unconstrained = c(c1, c2, c3),
constrained = c(u1, u2, u3)
)
df$constrained <- round(df$constrained)
df$unconstrained <- round(df$unconstrained)
return(df)
}
}
# Generate a summary of the sampling frame by strata
# For stream lengths
sample_frame_summary(
strm = strm,
constrained_strm = ca_strm,
roads = roads,
stream_order = "STREAM_ORDER",
summary_type = "stream_lengths")
# and stream crossings
sample_frame_summary(
strm = strm,
constrained_strm = ca_strm,
roads = roads,
stream_order = "STREAM_ORDER",
summary_type = "stream_crossings")
library(wsep.t2)
data(TsolumStreams)
data(TsolumRoads)
strm <- utm_projection(data = TsolumStreams)
roads <- utm_projection(data = TsolumRoads)
df1 <- sample_frame_summary(
strm = strm,
constrained_strm = strm,
roads = roads,
stream_order = "STREAM_ORDER",
summary_type = "stream_lengths")
df1
# Should be the same values if we dont input
df1$unconstrained - df1$constrained
# Should be the same values if we dont input
sum(df1$unconstrained - df1$constrained)
df1 <- sample_frame_summary(
strm = strm,
constrained_strm = strm,
roads = roads,
stream_order = "STREAM_ORDER",
summary_type = "stream_lengths")
# Should be the same values if we do not input
check <- sum(df1$unconstrained - df1$constrained)
testthat::expect_true(check == 0)
# and stream crossings
df2 <- sample_frame_summary(
strm = strm,
constrained_strm = strm,
roads = roads,
stream_order = "STREAM_ORDER",
summary_type = "stream_crossings")
# Should be the same values if we do not input
check <- sum(df2$unconstrained - df2$constrained)
testthat::expect_true(check == 0)
remove.packages("wsep.t2")
remove.packages("wsep.t2")
remove.packages("wsep.t2")
rm(list = ls())
devtools::load_all()
devtools::document()
?constrain_streams
devtools::test()  # R
devtools::check() # Operating system test
```r
# Generate a summary of the sampling frame by strata
# For stream lengths
df1 <- sample_frame_summary(
strm = strm,
constrained_strm = ca_strm,
roads = roads,
stream_order = "STREAM_ORDER",
summary_type = "stream_lengths")
print(df2)
# wsep.t2 #
## *The Watershed Status Evaluation Protocol - Tier 2 R-Package*
<!-- badges: start -->
[![Lifecycle:
Stable](https://img.shields.io/badge/lifecycle-stable.svg)](https://www.tidyverse.org/lifecycle/#stable)
[![CRAN](http://www.r-pkg.org/badges/version/MNAI.CPBT)](https://cran.r-project.org/package=MNAI.CPBT)
<!-- badges: end -->
<!--
[![Video Tutorial](https://img.youtube.com/vi/lt6KL8EK0OQ/0.jpg)](https://www.youtube.com/watch?v=lt6KL8EK0OQ)
-->
The WSEP Tier 2 field sampling package uses a probabilistic sample design to select sampling sites within a the watershed. Each of the three components (fish passage, sediment delivery, and riparian/stream channel) use a different sample design; however, they share underlying spatial data sets. These spatial layers should be compiled and processed early on to inform reconnaissance and planning. The WSEP Tier 2 R-package (wsep.t2) can be used to help process and assemble the spatial data needed to generate sampling sites for a watershed of interest.
## Installation
The easiest way to install the `wsep.t2` package is from within the [RStudio IDE](https://www.rstudio.com/products/rstudio/download/) using `remotes::install_github()`. At this time the package has not been published to CRAN so the default `install.packages()` will not work. Instead, use remotes (or devtools) to install the package directly from GitHub:
``` r
# You may need to install remotes
library(remotes)
# Choose all if promp to update packages
remotes::install_github("essatech/wsep.t2")
## Example Usage ##
An example dataset is included in the wsep.t2 package for the Tsolum River watershed in Courtenay British Columbia, but the model can be run on any watershed of interest. It is expected that users will start with a streamline network derived from the BCFWA (BC Freshwater Atlas) clipped to their watershed of interest. Another key data layer to get started is a roads vector dataset (spatial lines) within each watershed. The following section provides an example for the Tsolum River. It is expected that users will apply the tool to their watershed of interest.
### Import Stream and Road Data Layers ###
```r
# Run with sample dataset
library(wsep.t2)
data(TsolumStreams)
strm <- TsolumStreams
data(TsolumRoads)
roads <- TsolumRoads
# Import your own data here (update directories and uncomment lines)
# library(sf)
# strm <- st_read(dsn = "my_watershed.gdb", layer = "my_streams")
# roads <- st_read(dsn = "my_watershed.gdb", layer = "my_roads")
```
## Create the Stream Layer ##
Prior to sampling sites across a watershed several pre-processing steps are necessary to refine the stream network sampling frame. These pre-processing steps ensure that the field sampling program will be successful and reduce the probability of last minute adjustments in the field. The pre-processing steps are as follows:
1. Omit non-classified drainage (small streams are may be non-existent or intermittent)
2. Remove lakes and lentic wetlands (optional)
3. Remove Alpine areas (optional)
4. Restricted access due to ownership or safety (not included, but recommended)
```r
# Load the WSEP Tier 2 R-package
library(wsep.t2)
# Will must re-project our data so that x,y are cartesian coordinates with units of meters
strm <- utm_projection(data = strm)
# Then constrain the sampling frame to remove 1st order tribs less than 500 m in length and clip the upper 200 m off of other tributaries. see ?constrain_streams for details
c_ctrm <- constrain_streams(strm = strm,
length_remove = 500,
length_trim = 200)
# Remove lakes and other lotic reaches.
# Consider removing any other lakes manually or through a simple filter
c_strm <- remove_lentic_bcfwa(strm = c_ctrm,
EDGE_TYPE = "EDGE_TYPE")
# Remove alpine areas
# In this example set to all segments over 800 m (adjust this value for your region)
ca_strm <- remove_alpine_bcfwa(strm = c_strm,
elevation_threshold = 800)
# (Optional) Visualize original (raw) and constrained streams.
# Finalize and adjust with any additional filters
strm1_plot <- sf::st_zm(strm)
strm2_plot <- sf::st_zm(ca_strm)
plot(sf::st_geometry(strm1_plot), col = "lightgrey",
main = "Constrained Streams")
plot(sf::st_geometry(strm2_plot), col = "blue", add = TRUE)
legend("topright", c("original", "adjusted"),
col = c("lightgrey", "blue"), lwd = 1)
```
<img src='man/figures/constrained_stream.PNG' align="center" height="450" style="padding: 10px;"/>
### Define Strata as Stream Order ###
Create a new field called `strata` that divides the remaining stream network based on stream order: `stratum_1` < 3rd order streams and `stratum_2` ≥ 3rd order streams.
```r
ca_strm$strata <- NA
ca_strm$strata <- ifelse(ca_strm$STREAM_ORDER < 3, "stratum_1", ca_strm$strata)
ca_strm$strata <- ifelse(ca_strm$STREAM_ORDER >= 3, "stratum_2", ca_strm$strata)
plot(ca_strm["strata"], main = "Sampling Stratum")
```
## Site Type A: Stream Crossings ##
A list of stream-road crossings in the watershed can be generated by taking the intersection of the stream layer and the road layer. We can then use the stream crossing layer as our first sampling frame to select sites to assess connectivity (fish passage) and sediment inputs.
Site Type and strata: Generate a random sample from the list of stream crossings for each of the two strata (stratum 1: < 3rd order vs. stratum 2: ≥ 3rd order).
```r
# Ensure road spatial projection matches that of the stream layer
# and that units are in meters (cartesian coordinates)
roads <- utm_projection(data = roads)
# Define crossings as the intersection of streams and roads
crossings <- sf::st_intersection(ca_strm, roads)
# Take a random sample of crossings by strata
site_type_a <- grouped_random_sample(data = crossings,
group_name = "strata",
n = 40,
stream_order = "STREAM_ORDER"
)
# -------------------------------------------
# (Optional) visualize
strm_plot <- sf::st_zm(ca_strm)
road_plot <- sf::st_zm(roads)
plot(sf::st_geometry(strm_plot), col = "darkblue", main = "Site Type A (stream crossing)")
plot(sf::st_geometry(road_plot), add = TRUE, col = "burlywood")
plot(sf::st_geometry(site_type_a), add = TRUE, col = ifelse(site_type_a$strata == "stratum_1", "black", "red"), pch = 19)
legend("topright", c("roads", "streams", "stratum 1", "stratum 2"), col = c("burlywood", "darkblue", "black", "red"), lwd = c(1, 1, NA, NA), pch = c(NA, NA, 19, 19))
```
<img src='man/figures/site_type_a.PNG' align="center" height="450" style="padding: 10px;"/>
## Site Type B: Road Proximity ##
Sample streams in close proximity to roads.
1. Apply a buffer (Strata 1: 20 m for < 3rd order and, Strata 2: 40 m for ≥3rd order) streams.
2. Take the intersection of roads and this buffer.
3. Removing any stream crossings (site Type A), by excluding any cases within 100 m of a crossing to avoid double counting.
4. Removing any segments < 50 m in length unless they are near a switch-back (determined by manual review of the map). [manual step not automated in R code - added afterwards]
5. Provide the start point of the segment as well as the segment length and strata id (<3rd order vs. ≥ 3rd order) and mapping the entire segment on the field maps to facilitate sampling.
6. Generate a random sample from the Site Type B list the strata with < 3rd order streams.
7. Append the complete list of Site Type B from the ≥ 3rd order strata.
8. Create a field checklist with at least the following fields: unique identifier, coordinates of start point and end point, segment length, and Strata.
```r
# Run the function for road proximity samples
?road_proximity_sample
type_b <- road_proximity_sample(
n = 60,
strm = ca_strm,
roads = roads,
buffer_s1_m = 20,
buffer_s2_m = 40,
buffer_crossings_m = 50, # originally 100m
small_strm_segment_m = 30, # originally 50m
stream_order = "STREAM_ORDER"
)
# Distances adjusted to provide better fit for this urban watershed
# Get the points object
names(type_b)
site_type_b <- type_b$points
line_segments <- type_b$line_segments
table(site_type_b$strata)
# # Preview
# library(mapview)
# mapview(list(site_type_b, line_segments))
# -------------------------------------------
# (Optional) visualize
strm_plot <- sf::st_zm(ca_strm)
road_plot <- sf::st_zm(roads)
plot(sf::st_geometry(strm_plot), col = "darkblue", main = "Site Type B (road proximity)")
plot(sf::st_geometry(road_plot), add = TRUE, col = "burlywood")
plot(sf::st_geometry(site_type_b), add = TRUE, col = ifelse(site_type_b$strata == "stratum_1", "black", "red"), pch = 19)
legend("topright", c("roads", "streams", "stratum 1", "stratum 2"), col = c("burlywood", "darkblue", "black", "red"), lwd = c(1, 1, NA, NA), pch = c(NA, NA, 19, 19))
```
<img src='man/figures/site_type_b.PNG' align="center" height="450" style="padding: 10px;"/>
## Site Type C: Riparian (Component 3) ##
There are several site types for this component. This section provides guidance on how to generate the list of sample sites from the spatial layers above. Generate a GRTS sample from the list of stream crossings for each of the two strata (<3rd order vs. ≥ 3rd order).
```r
site_type_c_1 <- strm_crossings_grts(
n = 40,
strm = ca_strm[which(ca_strm$strata == "stratum_1"), ],
roads = roads,
stream_order = 'STREAM_ORDER'
)
site_type_c_2 <- strm_crossings_grts(
n = 40,
strm = ca_strm[which(ca_strm$strata == "stratum_2"), ],
roads = roads,
stream_order = 'STREAM_ORDER'
)
site_type_c <- rbind(site_type_c_1, site_type_c_2)
table(site_type_c$strata)
# -------------------------------------------
# (Optional) visualize
plot(sf::st_geometry(strm_plot), col = "darkblue", main = "Site Type C (riparian-crossings)")
plot(sf::st_geometry(road_plot), add = TRUE, col = "burlywood")
plot(sf::st_geometry(site_type_c), add = TRUE, col = ifelse(site_type_b$strata == "stratum_1", "black", "red"), pch = 19)
legend("topright", c("roads", "streams", "stratum 1", "stratum 2"), col = c("burlywood", "darkblue", "black", "red"), lwd = c(1, 1, NA, NA), pch = c(NA, NA, 19, 19))
```
<img src='man/figures/site_type_c.PNG' align="center" height="450" style="padding: 10px;"/>
```r
# (Optional) Visualize with Mapview
# install.packages("mapview")
# library(mapview)
# road_plot$col <- 1
# mapview(list(strm_plot["strata"], road_plot, site_type_a["strata"], site_type_b["strata"], site_type_c["strata"]))
```
<img src='man/figures/site_type_all.PNG' align="center" height="450" style="padding: 10px;"/>
## Export Data ##
Finally, when all the sampling frames (above) have been generated it is possible to export the sample sites in neatly formatted csv, shp and kml file formats for review and field planning. Use the `export_sites()` function after defining a local export directory.
```r
# Output directory
# Change this path for your computer!
output_dir <- "C:/Users/mbayly/Desktop/delete/my_sites"
export_sites(output_dir = output_dir,
site_type_a = site_type_a,
type_b = type_b,
site_type_c = site_type_c,
export_csv = TRUE,
export_shp = TRUE,
export_kml = TRUE)
```
<img src='man/figures/export_data.PNG' align="center" height="450" style="padding: 10px;"/>
## Sampling Frame Summary Table ##
(Optional) It also is convenient to produce a summary table of the entire sampling frame. This table summarizes the total length of streams by strata and the total count of stream crossings by strata.
```r
```r
# Generate a summary of the sampling frame by strata
# For stream lengths
df1 <- sample_frame_summary(
strm = strm,
constrained_strm = ca_strm,
roads = roads,
stream_order = "STREAM_ORDER",
summary_type = "stream_lengths")
print(df2)
```r
# Generate a summary of the sampling frame by strata
# For stream lengths
df1 <- sample_frame_summary(
strm = strm,
constrained_strm = ca_strm,
roads = roads,
stream_order = "STREAM_ORDER",
summary_type = "stream_lengths")
print(df1)
getwd()
write.csv(df1)
write.csv(df1, file = "df1.csv")
# and stream crossings
df2 <- sample_frame_summary(
strm = strm,
constrained_strm = ca_strm,
roads = roads,
stream_order = "STREAM_ORDER",
summary_type = "stream_crossings")
print(df2)
write.csv(df2, file = "df2.csv")
remove.packages("wsep.t2")
remove.packages("wsep.t2")
remove.packages("wsep.t2")
remove.packages("wsep.t2")
remove.packages("wsep.t2")
library(devtools)
rm(list = ls())
devtools::load_all()
devtools::document()
?constrain_streams
devtools::test()  # Run tests
devtools::check() # Operating system test
devtools::build_manual()
tinytex::tlmgr_install("makeindex")
pkgbuild::build()
pkgbuild::build(manual = TRUE)
pkgbuild::build(manual = TRUE)
?build_manual
getwd()
